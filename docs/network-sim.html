<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Hierarchical Network Simulator</title>
    <style>
      :root {
        --bg1: #0f1724;
        --bg2: #071024;
        --panel: #0b1220cc;
        --accent: #6ee7b7;
        --muted: #9aa6b2;
        --glass: rgba(255, 255, 255, 0.04);
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto,
          "Helvetica Neue", Arial;
      }
      body {
        background: linear-gradient(180deg, var(--bg1), var(--bg2));
        color: #e6f0f2;
        overflow: hidden;
      }

      .topbar {
        position: fixed;
        left: 12px;
        right: 12px;
        top: 12px;
        height: 54px;
        border-radius: 12px;
        padding: 8px 12px;
        display: flex;
        gap: 12px;
        align-items: center;
        backdrop-filter: blur(6px);
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.02)
        );
        box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
        z-index: 50;
      }
      .brand {
        display: flex;
        gap: 8px;
        align-items: center;
        font-weight: 700;
      }
      .brand .logo {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: linear-gradient(135deg, #10b981, #06b6d4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        color: #021;
        box-shadow: 0 6px 18px rgba(2, 6, 23, 0.6);
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-left: 8px;
      }
      button,
      .btn {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.01)
        );
        color: var(--accent);
        border: 1px solid rgba(255, 255, 255, 0.04);
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        backdrop-filter: blur(3px);
      }
      button.secondary {
        color: var(--muted);
        background: transparent;
        border: 1px dashed rgba(255, 255, 255, 0.03);
      }
      .search {
        margin-left: auto;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      input[type="text"],
      select {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.04);
        padding: 8px 10px;
        border-radius: 8px;
        color: inherit;
        outline: none;
      }

      #canvas-wrap {
        position: fixed;
        left: 12px;
        right: 12px;
        top: 78px;
        bottom: 12px;
        border-radius: 12px;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.01) 0 1px,
            transparent 1px 64px
          ),
          linear-gradient(180deg, rgba(2, 6, 23, 0.36), rgba(3, 7, 14, 0.2));
        cursor: grab;
        display: block;
      }

      .panel {
        position: fixed;
        right: 26px;
        top: 100px;
        width: 360px;
        max-height: calc(100% - 160px);
        padding: 12px;
        border-radius: 12px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6);
        z-index: 60;
        overflow: auto;
      }
      ::-webkit-scrollbar {
        display: none;
      }
      .panel h3 {
        margin: 4px 0 10px 0;
        color: var(--accent);
      }
      .list-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        border-radius: 8px;
        background: var(--glass);
        margin-bottom: 8px;
      }
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      label {
        font-size: 13px;
        color: var(--muted);
        display: block;
        margin-bottom: 6px;
      }

      #modal {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        z-index: 200;
      }
      .modal-card {
        width: 520px;
        background: linear-gradient(180deg, #021124, #031826);
        padding: 16px;
        border-radius: 12px;
        box-shadow: 0 30px 60px rgba(1, 6, 10, 0.7);
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .input {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
        width: 100%;
      }

      .log {
        font-family: monospace;
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.25), transparent);
        padding: 10px;
        border-radius: 8px;
        color: #d7f7ee;
        max-height: 32vh;
        overflow: auto;
        font-size: 13px;
      }
      .log .step {
        padding: 6px;
        border-radius: 6px;
        margin-bottom: 6px;
        background: rgba(0, 0, 0, 0.18);
      }

      .small {
        font-size: 12px;
      }
      .pin-badge {
        background: rgba(255, 255, 255, 0.04);
        padding: 4px 8px;
        border-radius: 8px;
        font-weight: 700;
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      .footer-hint {
        position: fixed;
        left: 12px;
        bottom: 12px;
        color: var(--muted);
        font-size: 13px;
        z-index: 60;
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand">
        <div class="logo">NS</div>
        <div>
          <div style="font-size: 14px">Network Simulator</div>
          <div class="muted" style="font-size: 12px">
            Hierarchical addressing & pocket routing visualizer
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="btn-add-node">âž• Add Node</button>
        <button id="btn-add-connection" class="secondary">
          ðŸ”€ Add Connection
        </button>
        <button id="btn-simulate" onclick="document.getElementById('btn-run-sim').click()" class="secondary">â–¶ Simulate Pocket</button>
        <button id="btn-clear" class="secondary">ðŸ—‘ Clear</button>
        <button id="btn-export">ðŸ’¾ Export</button>
        <button id="btn-import" class="secondary">ðŸ“‚ Import</button>
      </div>

      <div class="search">
        <label class="muted small"
          >Zoom: <span id="zoom-label">100%</span></label
        >
      </div>
    </div>

    <div id="canvas-wrap">
      <canvas id="canvas"></canvas>
    </div>

    <div class="panel" id="panel-right">
      <h3>Network Controls</h3>
      <div>
        <label>Selected Node</label>
        <div class="list-item" id="selected-info" style="min-height: 48px">
          <div style="flex: 1">
            <div id="sel-title" style="font-weight: 700">â€”</div>
            <div class="muted small" id="sel-address">â€”</div>
          </div>
          <div style="text-align: right">
            <div class="pin-badge" id="sel-pin">â€”</div>
          </div>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 8px">
          <button id="btn-edit-node">Edit</button>
          <button id="btn-delete-node" class="secondary">Delete</button>
          <button id="btn-center-node" class="secondary">Center</button>
        </div>
      </div>

      <hr
        style="
          margin: 12px 0;
          border: none;
          border-top: 1px solid rgba(255, 255, 255, 0.03);
        "
      />

      <h3>Connections</h3>
      <div id="connections-list" class="muted small">
        Select a node to see its connections.
      </div>

      <hr
        style="
          margin: 12px 0;
          border: none;
          border-top: 1px solid rgba(255, 255, 255, 0.03);
        "
      />

      <h3>Simulation</h3>
      <label>Source Node</label>
      <select id="sim-source" class="input"></select>
      <label>Destination Address (comma-separated segments, e.g. 1,2,3)</label>
      <input
        id="sim-dest"
        class="input"
        placeholder="e.g. 1,2,3 or choose a node below"
      />
      <label style="margin-top: 8px">Or choose destination node</label>
      <select id="sim-dest-node" class="input"></select>
      <div style="display: flex; gap: 8px; margin-top: 8px">
        <button id="btn-run-sim">Run step-by-step</button>
        <button id="btn-run-fast" class="secondary">Run fast</button>
        <button id="btn-stop-sim" class="secondary">Stop</button>
      </div>

      <hr
        style="
          margin: 12px 0;
          border: none;
          border-top: 1px solid rgba(255, 255, 255, 0.03);
        "
      />

      <h3>Logs</h3>
      <div id="log" class="log"></div>
    </div>

    <div class="footer-hint">
      Drag canvas to pan â€¢ Mouse wheel to zoom â€¢ Drag nodes to reposition â€¢
      Right-click node for quick actions
    </div>

    <!-- Modal -->
    <div id="modal">
      <div class="modal-card">
        <h3 id="modal-title">Edit Node</h3>
        <div style="display: grid; gap: 8px">
          <label>Label</label>
          <input id="node-label" class="input" placeholder="My Node" />
          <label>Address segments (comma separated numbers)</label>
          <input id="node-address" class="input" placeholder="e.g. 1,2,3" />
          <label
            >Parent (optional â€” pick a node to make this one a child; if blank
            it becomes a root)</label
          >
          <select id="node-parent" class="input">
            <option value="">-- none (root) --</option>
          </select>
          <div class="row" style="justify-content: flex-end; margin-top: 6px">
            <button id="modal-save">Save</button>
            <button id="modal-cancel" class="secondary">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      /*
  Network Simulator
  - Nodes have: id, label, address: number[]
  - Connections stored on node as outgoing connections: { toId, pin }
  - On simulation, Node.send logic uses connection.targetNode.address as the Connection.address
  - Visual and step-by-step log shows algorithm steps (match, matchIndex, eq, isChildren)
*/

      // Utilities
      const uid = () => Math.random().toString(36).slice(2, 9);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const stringifyAddr = (a) => (a.length ? a.join(".") : "(root)");

      // Algorithm functions ported from C++ logic
      function match(connectionAddr, pocketAddr) {
        const minLen = Math.min(connectionAddr.length, pocketAddr.length);
        let positive = 0;
        while (
          positive < minLen &&
          connectionAddr[positive] === pocketAddr[positive]
        )
          positive++;
        const negative = connectionAddr.length - positive;
        return { positive, negative };
      }
      function matchIndex(m) {
        return m.positive - m.negative;
      }
      function eq(a1, a2) {
        if (a1.length !== a2.length) return false;
        for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;
        return true;
      }
      function isChildren(other, you) {
        if (other.length <= you.length) return false;
        for (let i = 0; i < you.length; i++)
          if (other[i] !== you[i]) return false;
        return true;
      }

      // State
      let state = {
        nodes: [], // { id,label,address:[nums], x,y, connections:[{toId,pin}] }
      };
      const STORAGE_KEY = "net-sim-state";

      // Canvas interaction state
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let DPR = window.devicePixelRatio || 1;
      let view = { tx: 0, ty: 0, scale: 1 }; // transform world->screen: (x*scale+tx)
      let draggingCanvas = false,
        dragStart = null;
      let selectedNodeId = null;
      let addingConnection = { from: null }; // when add connection button pressed
      let simulationRun = { running: false, stop: false };

      // Grab important DOM elements early so functions can use them
      const selTitle = document.getElementById("sel-title");
      const selAddress = document.getElementById("sel-address");
      const selPin = document.getElementById("sel-pin");
      const connectionsList = document.getElementById("connections-list");
      const logEl = document.getElementById("log");
      const simSource = document.getElementById("sim-source");
      const simDestNode = document.getElementById("sim-dest-node");
      const simDestInput = document.getElementById("sim-dest");
      const zoomLabel = document.getElementById("zoom-label");

      // Init
      function resizeCanvas() {
        DPR = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * DPR;
        canvas.height = canvas.clientHeight * DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        draw();
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Persistence
      function saveState() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
          console.warn("save failed", e);
        }
      }
      function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          try {
            state = JSON.parse(raw);
          } catch (e) {
            console.warn("load error", e);
          }
        } else {
          // bootstrap sample
          state = { nodes: [] };
          const a = {
            id: uid(),
            label: "Root A",
            address: [1],
            x: -200,
            y: 0,
            connections: [],
          };
          const b = {
            id: uid(),
            label: "Child A.1",
            address: [1, 1],
            x: -80,
            y: -80,
            connections: [],
          };
          const c = {
            id: uid(),
            label: "Child A.2",
            address: [1, 2],
            x: -80,
            y: 80,
            connections: [],
          };
          a.connections.push({ toId: b.id, pin: 10 });
          a.connections.push({ toId: c.id, pin: 11 });
          b.connections.push({ toId: c.id, pin: 12 });
          state.nodes.push(a, b, c);
          saveState();
        }
      }
      loadState();
      refreshUI(); // safe because DOM elements above were grabbed already
      draw();

      // Helpers to manage nodes
      function findNode(id) {
        return state.nodes.find((n) => n.id === id);
      }
      function findNodeByAddress(addr) {
        return state.nodes.find((n) => eq(n.address, addr));
      }
      function getOutgoingConnections(node) {
        return node.connections.map((c) => ({
          ...c,
          target: findNode(c.toId),
        }));
      }
      function addNode(opts) {
        const node = {
          id: uid(),
          label: opts.label || "Node " + (state.nodes.length + 1),
          address: opts.address || [],
          x: opts.x || Math.random() * 800 - 400,
          y: opts.y || Math.random() * 600 - 300,
          connections: opts.connections || [],
        };
        state.nodes.push(node);
        saveState();
        refreshUI();
        draw();
        return node;
      }
      function deleteNode(id) {
        const node = findNode(id);
        if (!node) return;
        const children = state.nodes.filter((n) =>
          n.connections.some((c) => c.toId === id)
        );
        if (children.length) {
          const orphan = children.find((child) => {
            const parents = state.nodes.filter((n) =>
              n.connections.some((c) => c.toId === child.id)
            );
            return parents.length <= 1;
          });
          if (orphan) {
            if (
              !confirm(
                "Deleting this node will orphan at least one child node (make it root). Proceed?"
              )
            )
              return;
          }
        }
        state.nodes.forEach(
          (n) => (n.connections = n.connections.filter((c) => c.toId !== id))
        );
        state.nodes = state.nodes.filter((n) => n.id !== id);
        if (selectedNodeId === id) selectedNodeId = null;
        saveState();
        refreshUI();
        draw();
      }

      function addConnection(fromId, toId, pin) {
        const from = findNode(fromId),
          to = findNode(toId);
        if (!from || !to) return;
        if (from.connections.some((c) => c.toId === toId && c.pin === pin))
          return;
        from.connections.push({
          toId: toId,
          pin: pin || Math.floor(Math.random() * 250) + 1,
        });
        saveState();
        refreshUI();
        draw();
      }
      function removeConnection(fromId, toId) {
        const from = findNode(fromId);
        if (!from) return;
        const target = findNode(toId);
        const parents = state.nodes.filter((n) =>
          n.connections.some((c) => c.toId === toId)
        );
        if (parents.length <= 1) {
          if (
            !confirm(
              'Removing this connection will orphan node "' +
                (target ? target.label : "") +
                '". Are you sure?'
            )
          )
            return;
        }
        from.connections = from.connections.filter((c) => c.toId !== toId);
        saveState();
        refreshUI();
        draw();
      }

      function refreshUI() {
        // --- preserve current selections/values so periodic refresh doesn't clear them ---
        const prevSelectedNodeId = selectedNodeId;
        const prevSimSourceVal =
          simSource && simSource.value ? simSource.value : "";
        const prevSimDestNodeVal =
          simDestNode && simDestNode.value ? simDestNode.value : "";
        const prevSimDestInputVal =
          simDestInput && simDestInput.value ? simDestInput.value : "";

        // --- rebuild the sim selects (source / dest node) ---
        if (simSource) {
          simSource.innerHTML = '<option value="">-- select source --</option>';
        }
        if (simDestNode) {
          simDestNode.innerHTML =
            '<option value="">-- select dest node --</option>';
        }

        for (const n of state.nodes) {
          const label = `${n.label} â€” ${stringifyAddr(n.address)}`;
          if (simSource) {
            const opt = document.createElement("option");
            opt.value = n.id;
            opt.textContent = label;
            simSource.appendChild(opt);
          }
          if (simDestNode) {
            const opt2 = document.createElement("option");
            opt2.value = n.id;
            opt2.textContent = label;
            simDestNode.appendChild(opt2);
          }
        }

        // --- restore previous select/input values if the referenced node still exists ---
        const nodeExists = (id) => state.nodes.some((x) => x.id === id);
        if (simSource)
          simSource.value =
            prevSimSourceVal && nodeExists(prevSimSourceVal)
              ? prevSimSourceVal
              : "";
        if (simDestNode)
          simDestNode.value =
            prevSimDestNodeVal && nodeExists(prevSimDestNodeVal)
              ? prevSimDestNodeVal
              : "";
        if (simDestInput) simDestInput.value = prevSimDestInputVal;

        // --- restore selected node only if it still exists, otherwise clear selection ---
        if (prevSelectedNodeId && nodeExists(prevSelectedNodeId)) {
          selectedNodeId = prevSelectedNodeId;
        } else {
          selectedNodeId = null;
        }

        // --- update the Selected Node panel and connections list ---
        if (selectedNodeId) {
          const n = findNode(selectedNodeId);
          if (n) {
            selTitle.textContent = n.label || "â€”";
            selAddress.textContent =
              "Address: " + stringifyAddr(n.address || []);
            selPin.textContent =
              "Out: " + (n.connections ? n.connections.length : 0) + " â‹… in";

            const outs = getOutgoingConnections(n);
            if (!outs || outs.length === 0) {
              connectionsList.textContent = "No outgoing connections";
            } else {
              connectionsList.innerHTML = "";
              outs.forEach((o) => {
                const div = document.createElement("div");
                div.className = "list-item";
                div.innerHTML = `
            <div style="flex:1">
              <div style="font-weight:700">${
                o.target ? o.target.label : "(unknown)"
              }</div>
              <div class="muted small">${
                o.target ? stringifyAddr(o.target.address) : "address unknown"
              }</div>
            </div>
            <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
              <div class="pin-badge">${o.pin}</div>
              <div style="display:flex;gap:6px">
                <button class="btn btn-remove-conn small secondary" data-from="${
                  n.id
                }" data-to="${o.toId}">Remove</button>
              </div>
            </div>
          `;
                connectionsList.appendChild(div);
              });

              // hook up remove buttons (re-query after we've inserted them)
              Array.from(
                connectionsList.querySelectorAll(".btn-remove-conn")
              ).forEach((b) => {
                b.addEventListener("click", () => {
                  // removeConnection already validates orphaning and asks confirm
                  removeConnection(b.dataset.from, b.dataset.to);
                });
              });
            }
          } else {
            // fallback if findNode failed for some reason
            selTitle.textContent = "â€”";
            selAddress.textContent = "â€”";
            selPin.textContent = "â€”";
            connectionsList.textContent =
              "Select a node to see its connections";
          }
        } else {
          // no node selected
          selTitle.textContent = "â€”";
          selAddress.textContent = "â€”";
          selPin.textContent = "â€”";
          connectionsList.textContent = "Select a node to see its connections";
        }

        // --- persist state after UI rebuild ---
        saveState();
      }

      // Drawing
      function worldToScreen(x, y) {
        return { x: x * view.scale + view.tx, y: y * view.scale + view.ty };
      }
      function screenToWorld(x, y) {
        return { x: (x - view.tx) / view.scale, y: (y - view.ty) / view.scale };
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);
        drawGrid();
        for (const n of state.nodes) {
          for (const c of n.connections) {
            const target = findNode(c.toId);
            if (!target) continue;
            drawConnection(n, target, c.pin);
          }
        }
        for (const n of state.nodes) {
          drawNode(n, n.id === selectedNodeId);
        }
      }

      function drawGrid() {
        const w = canvas.width / DPR,
          h = canvas.height / DPR;
        ctx.save();
        ctx.translate(view.tx % (40 * view.scale), view.ty % (40 * view.scale));
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = "#082033";
        for (let x = -1000; x < w + 1000; x += 40 * view.scale) {
          ctx.fillRect(x, 0, 1, h);
        }
        for (let y = -1000; y < h + 1000; y += 40 * view.scale) {
          ctx.fillRect(0, y, w, 1);
        }
        ctx.restore();
      }

      function drawNode(n, selected) {
        const pos = worldToScreen(n.x, n.y);
        const w = 150 * Math.min(1, view.scale);
        const h = 58 * Math.min(1, view.scale);
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.beginPath();
        roundRect(ctx, -w / 2, -h / 2, w, h, 12 * Math.min(1, view.scale));
        const g = ctx.createLinearGradient(-w / 2, -h / 2, w / 2, h / 2);
        g.addColorStop(0, selected ? "#053f3a" : "rgba(255,255,255,0.02)");
        g.addColorStop(1, selected ? "#042c3a" : "rgba(255,255,255,0.01)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.lineWidth = selected ? 2 : 1;
        ctx.strokeStyle = selected ? "#6EE7B7" : "rgba(255,255,255,0.04)";
        ctx.stroke();

        ctx.fillStyle = "#dff6ee";
        ctx.font = `${14 * Math.min(1, view.scale)}px system-ui, sans-serif`;
        ctx.textAlign = "left";
        ctx.fillText(n.label, -w / 2 + 12, -h / 2 + 20);

        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = `${12 * Math.min(1, view.scale)}px monospace`;
        ctx.fillText(stringifyAddr(n.address), -w / 2 + 12, -h / 2 + 40);

        ctx.restore();
      }

      function drawConnection(from, to, pin, highlight = false) {
        const a = worldToScreen(from.x, from.y);
        const b = worldToScreen(to.x, to.y);
        const dx = b.x - a.x,
          dy = b.y - a.y;
        const dist = Math.hypot(dx, dy) || 1;
        const nx = dx / dist,
          ny = dy / dist;
        const start = {
          x: a.x + nx * 50 * Math.min(1, view.scale),
          y: a.y + ny * 30 * Math.min(1, view.scale),
        };
        const end = {
          x: b.x - nx * 50 * Math.min(1, view.scale),
          y: b.y - ny * 30 * Math.min(1, view.scale),
        };
        ctx.save();
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = highlight ? "#6EE7B7" : "rgba(255,255,255,0.08)";
        ctx.fillStyle = highlight ? "#6EE7B7" : "rgba(255,255,255,0.06)";
        ctx.lineWidth = highlight ? 3 : 1.4;
        ctx.beginPath();
        const mx = (start.x + end.x) / 2 + ny * 20;
        const my = (start.y + end.y) / 2 - nx * 20;
        ctx.moveTo(start.x, start.y);
        ctx.quadraticCurveTo(mx, my, end.x, end.y);
        ctx.stroke();
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const ah = 8 * Math.min(1, view.scale);
        ctx.beginPath();
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(
          end.x - ah * Math.cos(angle - 0.4),
          end.y - ah * Math.sin(angle - 0.4)
        );
        ctx.lineTo(
          end.x - ah * Math.cos(angle + 0.4),
          end.y - ah * Math.sin(angle + 0.4)
        );
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.font = `${11 * Math.min(1, view.scale)}px monospace`;
        ctx.textAlign = "center";
        const labelPos = getQuadraticPoint(start, { x: mx, y: my }, end, 0.5);
        ctx.fillText("pin:" + pin, labelPos.x, labelPos.y - 6);
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      function getQuadraticPoint(p0, p1, p2, t) {
        const x =
          (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;
        const y =
          (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;
        return { x, y };
      }

      // Canvas interactions
      let draggingNode = null;
      let dragNodeOffset = { x: 0, y: 0 };

      canvas.addEventListener("mousedown", (e) => {
        canvas.focus();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const hit = hitTestNode(x, y);
        if (e.button === 2) {
          e.preventDefault();
          if (hit) {
            selectedNodeId = hit.id;
            refreshUI();
            draw();
            showNodeContext(hit, e.clientX, e.clientY);
            return;
          }
        }
        if (hit) {
          selectedNodeId = hit.id;
          draggingNode = hit;
          dragNodeOffset = {
            x: hit.x - screenToWorld(x, y).x,
            y: hit.y - screenToWorld(x, y).y,
          };
          if (addingConnection.from) {
            if (addingConnection.from === hit.id) {
              alert("Cannot connect node to itself");
              addingConnection = { from: null };
              document
                .getElementById("btn-add-connection")
                .classList.remove("active");
              return;
            }
            const pin = Math.floor(Math.random() * 200) + 1;
            addConnection(addingConnection.from, hit.id, pin);
            addingConnection = { from: null };
            document
              .getElementById("btn-add-connection")
              .classList.remove("active");
            return;
          }
          refreshUI();
          draw();
          return;
        } else {
          draggingCanvas = true;
          dragStart = { x: e.clientX, y: e.clientY, tx: view.tx, ty: view.ty };
          canvas.style.cursor = "grabbing";
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if (draggingNode) {
          const world = screenToWorld(x, y);
          draggingNode.x = world.x + dragNodeOffset.x;
          draggingNode.y = world.y + dragNodeOffset.y;
          saveState();
          draw();
        } else if (draggingCanvas && dragStart) {
          view.tx = dragStart.tx + (e.clientX - dragStart.x);
          view.ty = dragStart.ty + (e.clientY - dragStart.y);
          zoomLabel.textContent = Math.round(view.scale * 100) + "%";
          draw();
        }
      });

      canvas.addEventListener("mouseup", (e) => {
        draggingNode = null;
        draggingCanvas = false;
        canvas.style.cursor = "grab";
      });
      canvas.addEventListener("mouseleave", () => {
        draggingNode = null;
        draggingCanvas = false;
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const oldScale = view.scale;
          const delta = -e.deltaY * 0.0015;
          view.scale = clamp(view.scale * (1 + delta), 0.25, 3.5);
          view.tx = px - (px - view.tx) * (view.scale / oldScale);
          view.ty = py - (py - view.ty) * (view.scale / oldScale);
          zoomLabel.textContent = Math.round(view.scale * 100) + "%";
          draw();
        },
        { passive: false }
      );

      function hitTestNode(sx, sy) {
        for (let i = state.nodes.length - 1; i >= 0; i--) {
          const n = state.nodes[i];
          const pos = worldToScreen(n.x, n.y);
          const w = 150 * Math.min(1, view.scale);
          const h = 58 * Math.min(1, view.scale);
          if (
            sx >= pos.x - w / 2 &&
            sx <= pos.x + w / 2 &&
            sy >= pos.y - h / 2 &&
            sy <= pos.y + h / 2
          ) {
            return n;
          }
        }
        return null;
      }

      function showNodeContext(node, clientX, clientY) {
        const menu = document.createElement("div");
        menu.style.position = "fixed";
        menu.style.left = clientX + "px";
        menu.style.top = clientY + "px";
        menu.style.background = "linear-gradient(180deg,#021827,#041624)";
        menu.style.padding = "8px";
        menu.style.borderRadius = "8px";
        menu.style.boxShadow = "0 12px 30px rgba(0,0,0,0.6)";
        menu.style.zIndex = 999;
        menu.innerHTML = `
    <div style="padding:6px 8px;cursor:pointer" id="m-edit">Edit Node</div>
    <div style="padding:6px 8px;cursor:pointer" id="m-delete">Delete Node</div>
    <div style="padding:6px 8px;cursor:pointer" id="m-start-from">Use as Simulation Source</div>
    <div style="padding:6px 8px;cursor:pointer" id="m-connect-to">Start connection from here</div>
  `;
        document.body.appendChild(menu);
        const removeMenu = () => menu.remove();
        setTimeout(() =>
          document.addEventListener("click", removeMenu, { once: true })
        );
        menu.querySelector("#m-edit").addEventListener("click", () => {
          removeMenu();
          openModalFor(node);
        });
        menu.querySelector("#m-delete").addEventListener("click", () => {
          removeMenu();
          deleteNode(node.id);
        });
        menu.querySelector("#m-start-from").addEventListener("click", () => {
          removeMenu();
          simSource.value = node.id;
        });
        menu.querySelector("#m-connect-to").addEventListener("click", () => {
          removeMenu();
          addingConnection.from = node.id;
          document.getElementById("btn-add-connection").classList.add("active");
          alert("Now click the node you want to connect to.");
        });
      }

      // Buttons
      document.getElementById("btn-add-node").addEventListener("click", () => {
        openModalFor();
      });
      document.getElementById("btn-edit-node").addEventListener("click", () => {
        if (!selectedNodeId) {
          alert("Select a node first");
          return;
        }
        openModalFor(findNode(selectedNodeId));
      });
      document
        .getElementById("btn-delete-node")
        .addEventListener("click", () => {
          if (!selectedNodeId) {
            alert("Select a node first");
            return;
          }
          deleteNode(selectedNodeId);
        });
      document
        .getElementById("btn-center-node")
        .addEventListener("click", () => {
          if (!selectedNodeId) {
            alert("Select a node first");
            return;
          }
          const n = findNode(selectedNodeId);
          const screenCenter = {
            x: canvas.clientWidth / 2,
            y: canvas.clientHeight / 2,
          };
          view.tx = screenCenter.x - n.x * view.scale;
          view.ty = screenCenter.y - n.y * view.scale;
          draw();
        });
      document
        .getElementById("btn-add-connection")
        .addEventListener("click", (e) => {
          if (addingConnection.from) {
            addingConnection = { from: null };
            e.target.classList.remove("active");
          } else {
            if (!selectedNodeId) {
              alert("Select a source node first (click a node)");
              return;
            }
            addingConnection.from = selectedNodeId;
            e.target.classList.add("active");
            alert(
              "Now click the target node to create a connection. (Right-click to cancel)"
            );
          }
        });
      document.getElementById("btn-clear").addEventListener("click", () => {
        if (!confirm("Clear all nodes and connections?")) return;
        state.nodes = [];
        saveState();
        refreshUI();
        draw();
      });
      document.getElementById("btn-export").addEventListener("click", () => {
        const data = JSON.stringify(state, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "net-state.json";
        a.click();
        URL.revokeObjectURL(url);
      });
      document.getElementById("btn-import").addEventListener("click", () => {
        const inp = document.createElement("input");
        inp.type = "file";
        inp.accept = "application/json";
        inp.onchange = (ev) => {
          const f = ev.target.files[0];
          if (!f) return;
          const r = new FileReader();
          r.onload = () => {
            try {
              const obj = JSON.parse(r.result);
              state = obj;
              saveState();
              refreshUI();
              draw();
            } catch (e) {
              alert("Invalid JSON");
            }
          };
          r.readAsText(f);
        };
        inp.click();
      });

      // Modal logic
      const modal = document.getElementById("modal");
      const modalTitle = document.getElementById("modal-title");
      const nodeLabelInput = document.getElementById("node-label");
      const nodeAddressInput = document.getElementById("node-address");
      const nodeParentSelect = document.getElementById("node-parent");
      let editingNodeId = null;

      function openModalFor(node) {
        nodeParentSelect.innerHTML =
          '<option value="">-- none (root) --</option>';
        state.nodes.forEach((n) => {
          nodeParentSelect.innerHTML += `<option value="${n.id}">${
            n.label
          } â€” ${stringifyAddr(n.address)}</option>`;
        });
        if (node) {
          editingNodeId = node.id;
          modalTitle.textContent = "Edit Node";
          nodeLabelInput.value = node.label;
          nodeAddressInput.value = node.address.join(",");
          nodeParentSelect.value = "";
        } else {
          editingNodeId = null;
          modalTitle.textContent = "Create Node";
          nodeLabelInput.value = "";
          nodeAddressInput.value = "";
          nodeParentSelect.value = "";
        }
        modal.style.display = "flex";
      }
      document
        .getElementById("modal-cancel")
        .addEventListener("click", () => (modal.style.display = "none"));
      document.getElementById("modal-save").addEventListener("click", () => {
        const label =
          nodeLabelInput.value.trim() || "Node " + (state.nodes.length + 1);
        const address = nodeAddressInput.value
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean)
          .map(Number)
          .filter((n) => !Number.isNaN(n));
        const parentId = nodeParentSelect.value || null;
        if (editingNodeId) {
          const node = findNode(editingNodeId);
          node.label = label;
          node.address = address;
          if (parentId) {
            const parent = findNode(parentId);
            if (parent && !parent.connections.some((c) => c.toId === node.id)) {
              parent.connections.push({
                toId: node.id,
                pin: Math.floor(Math.random() * 200) + 1,
              });
            }
          }
          saveState();
          refreshUI();
          draw();
        } else {
          const n = addNode({ label, address });
          if (parentId) {
            const parent = findNode(parentId);
            if (parent)
              parent.connections.push({
                toId: n.id,
                pin: Math.floor(Math.random() * 200) + 1,
              });
            saveState();
            refreshUI();
            draw();
          }
        }
        modal.style.display = "none";
      });

      // Simulation
      function log(msg, type = "info") {
        const el = document.createElement("div");
        el.className = "step";
        el.innerHTML = `<div style="font-weight:700">${type}</div><div style="margin-top:6px">${msg}</div>`;
        logEl.prepend(el);
      }
      function clearLog() {
        logEl.innerHTML = "";
      }

      document
        .getElementById("btn-run-sim")
        .addEventListener("click", () => runSimulation(true));
      document
        .getElementById("btn-run-fast")
        .addEventListener("click", () => runSimulation(false));
      document
        .getElementById("btn-stop-sim")
        .addEventListener("click", () => (simulationRun.stop = true));

      function parseAddressString(s) {
        if (!s) return [];
        return s
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean)
          .map(Number)
          .filter((n) => !Number.isNaN(n));
      }

      async function runSimulation(stepByStep = true) {
        const sourceId = simSource.value;
        let destAddr = parseAddressString(simDestInput.value);
        if (!destAddr.length) {
          if (simDestNode.value) {
            const targetNode = findNode(simDestNode.value);
            if (!targetNode) {
              alert("Destination node not found");
              return;
            }
            destAddr = targetNode.address.slice();
          } else {
            alert("Please choose source and destination (address or node)");
            return;
          }
        }
        if (!sourceId) {
          alert("Choose source node");
          return;
        }
        simulationRun.running = true;
        simulationRun.stop = false;
        clearLog();
        let current = findNode(sourceId);
        if (!current) return;
        const pocket = { address: destAddr.slice() };
        log(
          `<b>Starting simulation</b><div class="muted small">Source: ${
            current.label
          } â€” ${stringifyAddr(current.address)}<br>Destination: ${stringifyAddr(
            pocket.address
          )}</div>`,
          "start"
        );
        centerOnNode(current);
        await highlightNode(current, 600);
        let steps = 0;
        const visited = new Set();
        let delivered = false;

        while (steps < 128 && !simulationRun.stop) {
          steps++;
          const you = current.address;
          if (eq(you, pocket.address)) {
            log(
              `<b>Delivered</b>: Node ${
                current.label
              } address matches destination: ${stringifyAddr(you)}`,
              "delivered"
            );
            delivered = true;
            await highlightNode(current, 800, "#6EE7B7");
            break;
          }
          if (current.connections.length === 0) {
            log(
              `<b>Dead end</b>: Node ${current.label} has no outgoing connections. Packet dropped.`,
              "dead"
            );
            break;
          }

          log(
            `<b>Selecting best outgoing connection from ${current.label}</b>`,
            "step"
          );
          const isDirectChildren = isChildren(pocket.address, you);
          log(
            `isDirectChildren? <code>${isDirectChildren}</code> (destination is descendant of current node?)`
          );

          let sendConnection = current.connections[0];
          let bestMatchIndex = matchIndex(
            match(findNode(sendConnection.toId).address, pocket.address)
          );
          let bestAddressLength = findNode(sendConnection.toId).address.length;
          logCandidate(sendConnection, pocket, current);

          for (let i = 1; i < current.connections.length; i++) {
            const cand = current.connections[i];
            const candNode = findNode(cand.toId);
            const m = match(candNode.address, pocket.address);
            const idx = matchIndex(m);
            logCandidate(cand, pocket, current);
            if (idx > bestMatchIndex) {
              log(
                `âœ“ Candidate ${candNode.label} wins by higher matchIndex (${idx} > ${bestMatchIndex})`
              );
              sendConnection = cand;
              bestMatchIndex = idx;
              bestAddressLength = candNode.address.length;
            } else if (
              idx === bestMatchIndex &&
              candNode.address.length > bestAddressLength
            ) {
              log(
                `âœ“ Candidate ${candNode.label} wins tie-breaker by longer address length (${candNode.address.length} > ${bestAddressLength})`
              );
              sendConnection = cand;
              bestMatchIndex = idx;
              bestAddressLength = candNode.address.length;
            } else {
              log(`âœ— Candidate ${candNode.label} not chosen (idx ${idx})`);
            }
          }

          const sendConnNode = findNode(sendConnection.toId);
          if (isDirectChildren && !isChildren(sendConnNode.address, you)) {
            log(
              `<b>Routing blocked</b>: destination is a direct child of current node, but chosen connection (${sendConnNode.label}) is NOT a child of current; aborting send (returns 0)`,
              "blocked"
            );
            break;
          }

          log(
            `<b>Forwarding</b> via node ${sendConnNode.label} (pin ${sendConnection.pin}). matchIndex=${bestMatchIndex}`,
            "forward"
          );
          await highlightConnection(current, sendConnNode, 700);
          current = sendConnNode;
          centerOnNode(current);
          await highlightNode(current, 400);
          if (visited.has(current.id)) {
            log("<b>Loop detected</b> â€” stopping simulation", "dead");
            break;
          }
          visited.add(current.id);
          if (stepByStep) {
            await new Promise((r) => setTimeout(r, 600));
          } else {
            await new Promise((r) => setTimeout(r, 120));
          }
        }

        if (simulationRun.stop) {
          log("<b>Simulation stopped</b>", "stop");
        } else if (!delivered) {
          log("<b>Simulation ended</b>: destination not reached", "end");
        }
        simulationRun.running = false;
        simulationRun.stop = false;
      }

      function logCandidate(connection, pocket, current) {
        const target = findNode(connection.toId);
        if (!target) {
          log(`Candidate -> (unknown) pin ${connection.pin}`);
          return;
        }
        const connAddr = target.address;
        const m = match(connAddr, pocket.address);
        const idx = matchIndex(m);
        log(
          `<b>Candidate:</b> ${target.label} â€” address ${stringifyAddr(
            connAddr
          )} <div class="muted small">match.positive=${
            m.positive
          }, match.negative=${m.negative}, matchIndex=${idx}</div>`,
          "candidate"
        );
      }

      function highlightNode(node, ms = 500, color = "#6EE7B7") {
        return new Promise((r) => {
          const start = Date.now();
          node._highlight = ms;
          (function anim() {
            draw();
            const pos = worldToScreen(node.x, node.y);
            ctx.save();
            ctx.globalAlpha = 0.2 + 0.2 * Math.sin((Date.now() - start) / 120);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 60 * view.scale, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
            if (Date.now() - start < ms) requestAnimationFrame(anim);
            else {
              node._highlight = 0;
              draw();
              r();
            }
          })();
        });
      }

      function highlightConnection(a, b, ms = 500) {
        return new Promise((r) => {
          const start = Date.now();
          (function anim() {
            draw();
            drawConnection(a, b, "", true);
            if (Date.now() - start < ms) requestAnimationFrame(anim);
            else r();
          })();
        });
      }

      function centerOnNode(n) {
        const screenCenter = {
          x: canvas.clientWidth / 2,
          y: canvas.clientHeight / 2,
        };
        view.tx = (screenCenter.x - n.x - 360 / 2) * view.scale;
        view.ty = screenCenter.y - n.y * view.scale;
        draw();
      }

      (function tick() {
        draw();
        requestAnimationFrame(tick);
      })();

      document.addEventListener("keydown", (e) => {
        if (e.key === "Delete" && selectedNodeId) deleteNode(selectedNodeId);
        if (e.key === "s" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          saveState();
          alert("Saved");
        }
      });

      (function monitorStateChanges() {
        setInterval(refreshUI, 600);
      })();

      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      centerOnNode(state.nodes[0]);
    </script>
  </body>
</html>
