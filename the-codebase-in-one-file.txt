
//filepath: src\basic-main.cpp
// #include <Arduino.h>
// #include "./protocoll/index.hpp"
// #include "./user.hpp"

// PhysikalNode node;

// Address u1;
// Address u2;
// Address u3;

// void setup()
// {
//     Serial.begin(115200);

//     Serial.println();
//     Serial.println("Starting...");
//     Serial.println(String("Role: ") + (IS_SENDER ? "SENDER" : "RECEIVER"));

//     // User 1
//     u1.push_back(1);
//     u1.push_back(2);
//     u1.push_back(3);
//     // User 2
//     u2.push_back(1);
//     u2.push_back(27);
//     // User 3
//     u3.push_back(0);

//     node.onData = [](const char *data)
//     {
//         Serial.println("\nReceived:");
//         Serial.println(data);
//         Serial.println();
//     };

//     node.onError = [](String error)
//     {
//         Serial.println("\nError:");
//         Serial.println(error);
//         Serial.println();
//     };

// #if IS_SENDER
//     node.logicalNode.you = u1;
//     node.logicalNode.connections.push_back({u2, 25});
// #else
//     node.logicalNode.you = u2;
//     node.logicalNode.connections.push_back({u1, 25});
// #endif

//     node.start();
// }

// void loop()
// {
// #if IS_SENDER
//     delay(5000);
//     node.send(u2, "HEY  HEY   ");
//     delay(20000);
// #endif
// }


//filepath: src\main.cpp
#include <Arduino.h>

#include "webinterface/webinterface.hpp"

WebInterface webif;

void setup()
{
  Serial.begin(115200);
  webif.begin();
}

void loop()
{
}


//filepath: src\protocoll\check-pending-acks.hpp
#pragma once

#include "./physikal.hpp"
#include "./pending-packet.hpp"

#include <algorithm>

void PhysikalNode::checkPendingAcks()
{
    unsigned long currentTime = millis();

    for (auto it = pendingPackets.begin(); it != pendingPackets.end();)
    {
        PendingPacket &pending = *it;

        if (currentTime - pending.lastSendTime > RESEND_TIMEOUT)
        {
            if (pending.attempts < MAX_ATTEMPTS)
            {
                handlePacketRetry(pending, currentTime);
                ++it;
            }
            else
            {
                handlePacketFailure(it, currentTime);
            }
        }
        else
        {
            ++it;
        }
    }
}

void PhysikalNode::handlePacketRetry(PendingPacket &pending, unsigned long currentTime)
{
    pending.attempts++;
    pending.lastSendTime = currentTime;

    if (onError != nullptr)
    {
        onError("Checksum mismatch! Resending packet " +
                String(pending.pocket.checksum, HEX) +
                " attempt " + String(pending.attempts));
    }

    sendNormalPocket(pending.pocket, pending.sendPin);
}

void PhysikalNode::handlePacketFailure(vector<PendingPacket>::iterator &it, unsigned long currentTime)
{
    PendingPacket &pending = *it;

    if (onError != nullptr)
    {
        onError("Packet " + String(pending.pocket.checksum, HEX) +
                " failed 3 times. Removing connection and retrying on a new pin.");
    }

    uint8_t failedPin = pending.sendPin;

    auto connIt = std::find_if(
        logicalNode.connections.begin(),
        logicalNode.connections.end(),
        [failedPin](const Connection &conn)
        { return conn.pin == failedPin; });

    if (connIt != logicalNode.connections.end())
    {
        logicalNode.connections.erase(connIt);
    }

    if (!logicalNode.connections.empty())
    {
        uint8_t newPin = logicalNode.connections.front().pin;

        if (onError != nullptr)
        {
            onError("Resending on new connection pin: " + String(newPin));
        }

        pending.sendPin = newPin;
        pending.attempts = 1;
        pending.lastSendTime = currentTime;

        sendNormalPocket(pending.pocket, newPin);
        ++it;
    }
    else
    {
        if (onError != nullptr)
        {
            onError("No available logicalNode.connections to resend packet.");
        }

        it = pendingPackets.erase(it);
    }
}


//filepath: src\protocoll\index.hpp
#pragma once

#include "./logical.hpp"
#include "./physikal.hpp"

//filepath: src\protocoll\logical.hpp
#pragma once

#include <Arduino.h>
#include <vector>
#include <algorithm>
#include <string.h>

using namespace std;

struct Address : public vector<uint16_t>
{
};

struct Match
{
  uint16_t positive;
  uint16_t negative;
};

Match match(const Address &connection, const Address &pocket)
{
  size_t minLen = min(connection.size(), pocket.size());
  Match m = {0, 0};

  while (m.positive < minLen && connection[m.positive] == pocket[m.positive])
  {
    m.positive++;
  }
  m.negative = connection.size() - m.positive;

  return m;
}

int matchIndex(const Match &m)
{
  return m.positive - m.negative;
}

bool eq(const Address &a1, const Address &a2)
{
  if (a1.size() != a2.size())
    return false;

  for (size_t i = 0; i < a1.size(); i++)
  {
    if (a1.at(i) != a2.at(i))
      return false;
  }

  return true;
}

struct Connection
{
  Address address;
  uint8_t pin;
};

#include "./pocket.hpp"

struct Node
{
  vector<Connection> connections;
  Address you;

  uint8_t send(Pocket p)
  {
    if (connections.empty())
    {
      Serial.println("No available connections to send data.");
      return 0;
    }

    Connection sendConnection = connections.at(0);

    int bestMatchIndex = matchIndex(match(sendConnection.address, p.address));
    int bestAdressLength = sendConnection.address.size();

    for (size_t i = 1; i < connections.size(); i++)
    {
      int currentMatchIndex = matchIndex(match(connections[i].address, p.address));
      if (currentMatchIndex > bestMatchIndex)
      {
        sendConnection = connections[i];
        bestMatchIndex = currentMatchIndex;
      }
      else if (currentMatchIndex == bestMatchIndex && bestAdressLength < sendConnection.address.size())
      {
        bestAdressLength = sendConnection.address.size();
        sendConnection = connections[i];
        bestMatchIndex = currentMatchIndex;
      }
    }

    Serial.print("Sending data via pin ");
    Serial.println(sendConnection.pin);

    return sendConnection.pin;
  }

  uint8_t recieve(Pocket p)
  {
    if (eq(you, p.address))
    {
      return 0;
    }
    else
    {
      return send(p);
    }
  }
};

//filepath: src\protocoll\pending-packet.hpp
#pragma once

#include <Arduino.h>
#include "./logical.hpp"

struct PendingPacket
{
    Pocket pocket;
    uint8_t sendPin;
    uint8_t attempts;
    unsigned long lastSendTime; // in milliseconds

    PendingPacket(const Pocket &p, uint8_t pin, uint8_t att, unsigned long time)
        : pocket(p), sendPin(pin), attempts(att), lastSendTime(time) {}
};

//filepath: src\protocoll\physikal.hpp
#pragma once

#include <Arduino.h>
#include <vector>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <functional>

#include "logical.hpp"
#include "pending-packet.hpp"

#define NORMAL_SEND 1
#define RETURN_OK 2
#define RESEND_TIMEOUT 5000 // milliseconds
#define MAX_ATTEMPTS 50

using std::vector;

struct PhysikalNode
{
  Node logicalNode;
  TaskHandle_t taskHandle = nullptr;
  vector<PendingPacket> pendingPackets;

  std::function<void(const char *data)> onData = nullptr;
  std::function<void(String)> onError = nullptr;

  static void loopTask(void *params)
  {
    static_cast<PhysikalNode *>(params)->loop();
  }

  void receivePocket(uint8_t pin);

  void sendNormalPocket(Pocket &p, uint8_t pin);

  // Handles a packet once received.
  void on(Pocket p)
  {
    uint8_t sendPin = logicalNode.recieve(p);

    // 0 == Selv Send
    if (sendPin == 0)
    {
      onData(p.data);
    }
    else
    {
      sendNormalPocket(p, sendPin);
    }
  }

  // Finds and acknowledges the pending packet based on its checksum.
  void acknowledge(uint16_t hash)
  {
    for (auto it = pendingPackets.begin(); it != pendingPackets.end(); ++it)
    {
      if (it->pocket.checksum == hash)
      {
        pendingPackets.erase(it);
        break;
      }
    }
  }

  // Checks for packets that need to be resent.
  void checkPendingAcks();
  void handlePacketRetry(PendingPacket &pending, unsigned long currentTime);
  void handlePacketFailure(vector<PendingPacket>::iterator &it, unsigned long currentTime);

  // The main loopâ€”pulses the connections and checks for incoming data or ACKs.
  void loop()
  {
    for (auto conn : logicalNode.connections)
    {
      pinMode(conn.pin, INPUT);
    }

    while (true)
    {
      for (const auto &conn : logicalNode.connections)
      {
        if (digitalRead(conn.pin) == HIGH)
        {
          delayMicroseconds(1500);
          // wait on bit + a half (read in the middle of the signal)
          receivePocket(conn.pin);
        }
      }
      checkPendingAcks();
      // Yield to other tasks to avoid watchdog resets.
      vTaskDelay(pdMS_TO_TICKS(1));
    }
  }

  // Starts the FreeRTOS task for handling the physical layer communications.
  void start()
  {
    if (taskHandle == nullptr)
    {
      xTaskCreate(loopTask, "PhysLoop", 4096, this, 1, &taskHandle);
    }
  }

  // Stops the FreeRTOS task, if running.
  void stop()
  {
    if (taskHandle != nullptr)
    {
      vTaskDelete(taskHandle);
      taskHandle = nullptr;
    }
  }

  // Initiates the sending of a packet with the given address and data.
  void send(Address address, const char *data)
  {
    on(Pocket(address, data));
  }
};

#include "./raw-communication.hpp"
#include "./check-pending-acks.hpp"
#include "./receive-pocket.hpp"
#include "./send-normal-pocket.hpp"


//filepath: src\protocoll\pocket.hpp
#pragma once
#include <cstring>

struct Pocket
{
    Address address;
    char data[11];
    uint16_t checksum;

    Pocket(Address a, const char *d) : address(a)
    {
        strncpy(data, d, 10);
        data[10] = '\0';
        checksum = calculateChecksum();
    }

    uint16_t calculateChecksum() const
    {
        uint16_t sum1 = 0;
        uint16_t sum2 = 0;

        // Add address parts
        for (uint16_t part : address)
        {
            sum1 = (sum1 + part) % 255;
            sum2 = (sum2 + sum1) % 255;
        }

        // Add data bytes
        for (int i = 0; i < 10; i++)
        {
            sum1 = (sum1 + static_cast<uint8_t>(data[i])) % 255;
            sum2 = (sum2 + sum1) % 255;
        }

        return ((sum2 << 8) | sum1) ^ address.size(); // Combine sums into one 16-bit checksum xor with the adress length
    }
};


//filepath: src\protocoll\raw-communication.hpp
#pragma once

#include <Arduino.h>

uint8_t readByte(uint8_t pin)
{
    uint8_t value = 0;
    for (int i = 0; i < 8; i++)
    {
        value |= (digitalRead(pin) << (7 - i));
        delayMicroseconds(1000);
    }
    return value;
}

uint16_t readUInt16(uint8_t pin)
{
    uint8_t low = readByte(pin);
    uint8_t high = readByte(pin);
    return (high << 8) | low;
}

void sendByte(uint8_t pin, uint8_t byte)
{
    for (int i = 7; i >= 0; i--)
    {
        digitalWrite(pin, (byte >> i) & 1);
        delayMicroseconds(1000);
    }
    digitalWrite(pin, LOW);
}

void sendUInt16(uint8_t pin, uint16_t val)
{
    sendByte(pin, val & 0xFF);
    sendByte(pin, val >> 8);
}

//filepath: src\protocoll\receive-pocket.hpp
#pragma once

#include "./physikal.hpp"

void sendAck(uint8_t pin, uint16_t checksum)
{
    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);
    delayMicroseconds(1000);

    sendByte(pin, RETURN_OK);
    sendUInt16(pin, checksum);

    pinMode(pin, INPUT);
}

void PhysikalNode::receivePocket(uint8_t pin)
{
    uint8_t pocketType = readByte(pin);

    if (pocketType == NORMAL_SEND)
    {
        uint16_t addrSize = readUInt16(pin);
        Address address;
        address.reserve(addrSize);
        for (int i = 0; i < addrSize; i++)
        {
            address.push_back(readUInt16(pin));
        }

        char data[11];
        for (int i = 0; i < 10; i++)
        {
            data[i] = readByte(pin);
        }
        data[10] = '\0';

        uint16_t checksum = readUInt16(pin);

        Pocket p(address, data);

        if (p.checksum != checksum)
        {
            onError(String("ERROR=") + data);

            if (onError != nullptr)
            {
                onError("Checksum mismatch! Data:");
                onError(data);
            }
            return;
        }

        sendAck(pin, p.checksum);

        on(p);
    }
    else if (pocketType == RETURN_OK)
    {
        uint16_t hash = readUInt16(pin);
        acknowledge(hash);
    }
}

//filepath: src\protocoll\send-normal-pocket.hpp
#pragma once

#include "./physikal.hpp"

void PhysikalNode::sendNormalPocket(Pocket &p, uint8_t pin)
{
    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);
    delayMicroseconds(1000);

    sendByte(pin, NORMAL_SEND);
    sendUInt16(pin, p.address.size());
    for (auto a : p.address)
    {
        sendUInt16(pin, a);
    }
    for (int i = 0; i < 10; i++)
    {
        sendByte(pin, p.data[i]);
    }

    sendUInt16(pin, p.checksum);

    pinMode(pin, INPUT); // Switch back to receive mode

    // Add packet to pendingPackets only if it is not already pending
    for (auto &pending : pendingPackets)
    {
        if (pending.pocket.checksum == p.checksum)
        {
            return;
        }
    }

    pendingPackets.push_back(PendingPacket(p, pin, 1, millis()));
}

//filepath: src\user.hpp
#define USER 1


//filepath: src\webinterface\webinterface.cpp
#include "webinterface.hpp"
#include <esp_system.h>

#define WIFI_CRED_FILE "/wifi.txt"
#define CONN_FILE "/connections.txt"
#define AP_SUFFIX_FILE "/apsuffix.txt"
#define DEFAULT_AP_SSID "NodeAP"
#define WIFI_CONNECT_TIMEOUT_MS 10000

WebInterface::WebInterface(uint16_t port)
    : serverPort(port), server(port)
{
}

void WebInterface::begin()
{
    if (!LittleFS.begin())
    {
        Serial.println("Failed to mount LittleFS");
    }

    // Load or generate persistent AP suffix
    loadAPSuffix();

    // Load Wi-Fi credentials and attempt connection
    loadCredentials();
    if (!wifiSSID.isEmpty() && !connectWiFi(wifiSSID, wifiPassword))
    {
        // Start AP with persistent suffix
        String fullSSID = String(DEFAULT_AP_SSID) + "_" + String(apSuffix);
        Serial.printf("Starting AP mode: %s\n", fullSSID.c_str());
        WiFi.softAP(fullSSID.c_str());
    }

    loadConnections();

    xTaskCreatePinnedToCore(
        webTask,
        "WebServerTask",
        8192,
        this,
        1,
        nullptr,
        1);
}

void WebInterface::loadAPSuffix()
{
    if (LittleFS.exists(AP_SUFFIX_FILE))
    {
        File f = LittleFS.open(AP_SUFFIX_FILE, "r");
        apSuffix = f.readStringUntil('\n').toInt();
        f.close();
    }
    else
    {
        // Generate a random 16-bit suffix
        apSuffix = esp_random() & 0xFFFF;
        File f = LittleFS.open(AP_SUFFIX_FILE, "w");
        if (f)
        {
            f.println(apSuffix);
            f.close();
        }
    }
}

void WebInterface::webTask(void *param)
{
    WebInterface *self = static_cast<WebInterface *>(param);
    self->setupRoutes();
    self->server.begin();
    Serial.printf("Web server running on port %u\n", self->serverPort);

    while (true)
    {
        self->server.handleClient();
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

void WebInterface::setupRoutes()
{
    server.on("/", HTTP_GET, [&]()
              { handleRoot(); });
    server.on("/wifi", HTTP_GET, [&]()
              { handleWifi(); });
    server.on("/wifi/connect", HTTP_GET, [&]()
              { handleWifiConnect(); });
    server.on("/connections", HTTP_GET, [&]()
              { handleConnections(); });
    server.on("/connections/save", HTTP_POST, [&]()
              { handleConnectionsSave(); });
    server.onNotFound([&]()
                      { server.send(404, "text/plain", "Not Found"); });
}

void WebInterface::handleRoot()
{
    if (WiFi.status() == WL_CONNECTED)
    {
        server.sendHeader("Location", "/connections");
        server.send(302, "text/plain", "");
    }
    else
    {
        server.sendHeader("Location", "/wifi");
        server.send(302, "text/plain", "");
    }
}

void WebInterface::handleWifi()
{
    int n = WiFi.scanNetworks(true);
    String options;
    for (int i = 0; i < n; ++i)
    {
        options += "<option value='" + WiFi.SSID(i) + "'>" + WiFi.SSID(i) + "</option>";
    }

    static const char *page = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <title>Wi-Fi Setup</title>
</head>
<body class="p-4">
  <div class="container">
    <h2>Wi-Fi Setup</h2>
    <form action="/wifi/connect" method="get">
      <div class="mb-3">
        <label class="form-label">SSID</label>
        <select name="ssid" class="form-select">")rawliteral";
    String html = String(page) + options + R"rawliteral(
        </select>
      </div>
      <div class="mb-3">
        <label class="form-label">Password</label>
        <input type="password" name="pass" class="form-control" required>
      </div>
      <button type="submit" class="btn btn-primary">Connect</button>
    </form>
  </div>
</body>
</html>
)rawliteral";
    server.send(200, "text/html", html);
}

void WebInterface::handleWifiConnect()
{
    String ssid = server.arg("ssid");
    String pass = server.arg("pass");
    if (connectWiFi(ssid, pass))
    {
        wifiSSID = ssid;
        wifiPassword = pass;
        saveCredentials();
        server.sendHeader("Location", "/connections");
        server.send(302, "text/plain", "");
    }
    else
    {
        server.send(200, "text/html", R"rawliteral(
<p>Connection failed. <a href='/wifi'>Try again</a></p>
)rawliteral");
    }
}

void WebInterface::handleConnections()
{
    // Scan available Wi-Fi networks and list them
    int n = WiFi.scanNetworks(true);
    String netList = "<ul class='list-group mb-3'>";
    for (int i = 0; i < n; ++i)
    {
        netList += "<li class='list-group-item'>" + WiFi.SSID(i) + "</li>";
    }
    netList += "</ul>";

    // Existing connections table rows
    String rows;
    for (auto &c : connections)
    {
        String addr;
        for (size_t i = 0; i < c.address.size(); ++i)
        {
            addr += String(c.address[i]) + (i + 1 < c.address.size() ? "," : "");
        }
        rows += "<tr>"
                "<td><input name='address[]' value='" +
                addr + "' class='form-control' required></td>"
                       "<td><input type='number' name='pin[]' value='" +
                String(c.pin) + "' class='form-control' required></td>"
                                "<td><button type='button' class='btn btn-danger' onclick='removeRow(this)'>X</button></td>"
                                "</tr>";
    }

    static const char *page = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <title>Connection Manager</title>
</head>
<body class="p-4">
  <div class="container">
    <h2>Available Wi-Fi Networks</h2>
)rawliteral";
    String html = String(page) + netList + R"rawliteral(
    <h2>Connections</h2>
    <form action="/connections/save" method="post">
      <table class="table">
        <thead>
          <tr><th>Address</th><th>Pin</th><th></th></tr>
        </thead>
        <tbody>
)rawliteral" + rows +
                  R"rawliteral(
        </tbody>
      </table>
      <button type="button" class="btn btn-secondary mb-3" onclick="addRow()">Add</button>
      <button type="submit" class="btn btn-primary">Save</button>
    </form>
  </div>
  <script>
    function addRow() {
      const tbl = document.querySelector('tbody');
      const row = document.createElement('tr');
      row.innerHTML = `
        <td><input name='address[]' class='form-control' required></td>
        <td><input type='number' name='pin[]' class='form-control' required></td>
        <td><button type='button' class='btn btn-danger' onclick='removeRow(this)'>X</button></td>
      `;
      tbl.appendChild(row);
    }
    function removeRow(btn) {
      btn.closest('tr').remove();
    }
  </script>
</body>
</html>
)rawliteral";
    server.send(200, "text/html", html);
}

void WebInterface::handleConnectionsSave()
{
    std::vector<String> addrs, pins;
    for (int i = 0; i < server.args(); ++i)
    {
        if (server.argName(i) == "address[]")
            addrs.push_back(server.arg(i));
        else if (server.argName(i) == "pin[]")
            pins.push_back(server.arg(i));
    }
    connections.clear();
    for (size_t i = 0; i < addrs.size() && i < pins.size(); ++i)
    {
        Connection c;
        std::istringstream ss(addrs[i].c_str());
        uint16_t v;
        while (ss >> v)
        {
            c.address.push_back(v);
            if (ss.peek() == ',')
                ss.ignore();
        }
        c.pin = static_cast<uint8_t>(pins[i].toInt());
        connections.push_back(c);
    }
    saveConnections();
    server.sendHeader("Location", "/connections");
    server.send(302, "text/plain", "");
}

bool WebInterface::connectWiFi(const String &ssid, const String &password)
{
    WiFi.begin(ssid.c_str(), password.c_str());
    uint32_t start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < WIFI_CONNECT_TIMEOUT_MS)
    {
        delay(500);
    }
    if (WiFi.status() == WL_CONNECTED)
    {
        Serial.print("Connected to ");
        Serial.println(ssid);
        return true;
    }
    Serial.print("Failed to connect to ");
    Serial.println(ssid);
    return false;
}

void WebInterface::loadCredentials()
{
    if (!LittleFS.exists(WIFI_CRED_FILE))
        return;
    File f = LittleFS.open(WIFI_CRED_FILE, "r");
    wifiSSID = f.readStringUntil('\n');
    wifiPassword = f.readStringUntil('\n');
    f.close();
}

void WebInterface::saveCredentials()
{
    File f = LittleFS.open(WIFI_CRED_FILE, "w");
    f.println(wifiSSID);
    f.println(wifiPassword);
    f.close();
}

void WebInterface::loadConnections()
{
    connections.clear();
    if (!LittleFS.exists(CONN_FILE))
        return;
    File f = LittleFS.open(CONN_FILE, "r");
    while (f.available())
    {
        String line = f.readStringUntil('\n');
        int sep = line.indexOf(':');
        if (sep < 0)
            continue;
        String addrStr = line.substring(0, sep);
        String pinStr = line.substring(sep + 1);
        Connection c;
        std::istringstream ss(addrStr.c_str());
        uint16_t v;
        while (ss >> v)
        {
            c.address.push_back(v);
            if (ss.peek() == ',')
                ss.ignore();
        }
        c.pin = static_cast<uint8_t>(pinStr.toInt());
        connections.push_back(c);
    }
    f.close();
}

void WebInterface::saveConnections()
{
    File f = LittleFS.open(CONN_FILE, "w");
    for (auto &c : connections)
    {
        for (size_t i = 0; i < c.address.size(); ++i)
        {
            f.print(c.address[i]);
            if (i + 1 < c.address.size())
                f.print(',');
        }
        f.print(':');
        f.println(c.pin);
    }
    f.close();
}


//filepath: src\webinterface\webinterface.hpp
#pragma once

#include <esp_system.h>
#include <WiFi.h>
#include <WebServer.h>
#include <LittleFS.h>
#include <vector>
#include <sstream>

#include "../protocoll/index.hpp"

class WebInterface
{
public:
    explicit WebInterface(uint16_t port = 80);
    void begin();

    // Retrieve saved connection configurations
    const std::vector<Connection> &getConnections() const { return connections; }

private:
    // FreeRTOS task entry point for handling web requests
    static void webTask(void *param);

    // Route setup and handlers
    void setupRoutes();
    void handleRoot();
    void handleWifi();
    void handleWifiConnect();
    void handleConnections();
    void handleConnectionsSave();

    // Wi-Fi and storage utilities
    bool connectWiFi(const String &ssid, const String &password);
    void loadCredentials();
    void saveCredentials();
    void loadConnections();
    void saveConnections();
    void loadAPSuffix();

    // Underlying HTTP server
    WebServer server;

    // Stored Wi-Fi credentials
    String wifiSSID;
    String wifiPassword;

    // Persistent random suffix for AP name
    uint16_t apSuffix = 0;

    // Saved network connections (addresses and pins)
    std::vector<Connection> connections;

    // TCP port for HTTP server
    uint16_t serverPort;
};

