
//filepath: src\main.cpp
#include <Arduino.h>
#include <HardwareSerial.h>
#include "./protocoll/index.hpp"

#include "./user.hpp"

PhysikalNode node;

void setup()
{
  Serial.begin(115200);
  while (!Serial)
  {
  }

  Serial.println();
  Serial.println();
  Serial.println();
  Serial.println();
  Serial.println(String("Starting... ") + (IS_SENDER ? "SENDER" : "RECEIVER"));

  node.onData = [](const char *data)
  {
    Serial.println();
    Serial.println("Received To You: ");
    Serial.println(data);
    Serial.println();
  };

  Address u1;
  u1.push_back(1);
  u1.push_back(2);
  u1.push_back(3);

  Address u2;
  u2.push_back(1);
  u2.push_back(27);

  Address u3;
  u2.push_back(0);

#if IS_SENDER
  node.logicalNode.you = u1;
  node.logicalNode.connections.push_back({u2, 25});
#else
  node.logicalNode.you = u2;
  node.logicalNode.connections.push_back({u1, 25});
#endif
  node.start();
#if IS_SENDER
  delay(5000);
  node.send(u2, "HELLO_____");
#endif
}

void loop() {}

//filepath: src\protocoll\check-pending-acks.hpp
#pragma once

#include "./physikal.hpp"

void PhysikalNode::checkPendingAcks()
{
    unsigned long currentTime = millis();

    for (auto it = pendingPackets.begin(); it != pendingPackets.end();)
    {
        PendingPacket &pending = *it;
        if (currentTime - pending.lastSendTime > RESEND_TIMEOUT)
        {
            if (pending.attempts < MAX_ATTEMPTS)
            {
                pending.attempts++;
                pending.lastSendTime = currentTime;
                Serial.print("Resending packet ");
                Serial.print(pending.pocket.checksum, HEX);
                Serial.print(" attempt ");
                Serial.println(pending.attempts);
                sendNormalPocket(pending.pocket, pending.sendPin);
                ++it;
            }
            else
            {
                Serial.print("Packet ");
                Serial.print(pending.pocket.checksum, HEX);
                Serial.println(" failed 3 times. Removing connection and retrying on a new pin.");
                uint8_t failedPin = pending.sendPin;

                // Erase the failed connection from the logicalNode
                for (auto connIt = logicalNode.connections.begin(); connIt != logicalNode.connections.end(); ++connIt)
                {
                    if (connIt->pin == failedPin)
                    {
                        logicalNode.connections.erase(connIt);
                        break;
                    }
                }
                // If an alternative connection exists, update and resend
                if (!logicalNode.connections.empty())
                {
                    uint8_t newPin = logicalNode.connections[0].pin;
                    Serial.print("Resending on new connection pin: ");
                    Serial.println(newPin);
                    pending.sendPin = newPin;
                    pending.attempts = 1;
                    pending.lastSendTime = currentTime;
                    sendNormalPocket(pending.pocket, newPin);
                    ++it;
                }
                else
                {
                    Serial.println("No available logicalNode.connections to resend packet.");
                    it = pendingPackets.erase(it);
                }
            }
        }
        else
        {
            ++it;
        }
    }
}

//filepath: src\protocoll\index.hpp
#pragma once

#include "./logical.hpp"
#include "./physikal.hpp"

//filepath: src\protocoll\logical.hpp
#pragma once

#include <Arduino.h>
#include <vector>
#include <algorithm>
#include <string.h>

using namespace std;

struct Address : public vector<uint16_t>
{
};

struct Match
{
  int positive;
  int negative;
};

Match match(const Address &a1, const Address &a2)
{
  size_t maxLen = max(a1.size(), a2.size());
  size_t minLen = min(a1.size(), a2.size());
  Match m = {0, 0};

  while (m.positive < minLen && a1[m.positive] == a2[m.positive])
  {
    m.positive++;
  }

  m.negative = maxLen - 1 - m.positive;
  return m;
}

bool eq(const Address &a1, const Address &a2)
{
  if (a1.size() != a2.size())
    return false;

  for (int i = 0; i < a1.size(); i++)
  {
    if (a1.at(i) != a2.at(i))
      return false;
  }

  return true;
}

struct Connection
{
  Address address;
  uint8_t pin;
};

struct Pocket
{
  Address address;
  char data[11];
  uint16_t checksum;

  Pocket(Address a, const char *d) : address(a)
  {
    strncpy(data, d, 10);
    data[10] = '\0';
    checksum = calculateChecksum();
  }

  uint16_t calculateChecksum()
  {
    uint16_t sum = 0;
    for (uint16_t part : address)
      sum ^= part;
    for (int i = 0; i < 10; i++)
      sum ^= data[i];
    return sum;
  }
};

struct Node
{
  vector<Connection> connections;
  Address you;

  uint8_t send(Pocket p)
  {
    if (connections.empty())
    {
      Serial.println("No available connections to send data.");
      return 0;
    }

    Match bestMatch = {0, 0};
    vector<Connection> sendConnections;
    Connection sendConnection = connections.at(0);

    for (const auto &connection : connections)
    {
      Match currentMatch = match(connection.address, p.address);
      if (bestMatch.positive <= currentMatch.positive)
      {
        if (bestMatch.positive < currentMatch.positive)
        {
          sendConnections.clear();
        }
        bestMatch = currentMatch;
        sendConnections.push_back(connection);
      }
    }

    bestMatch = match(sendConnection.address, p.address);
    for (const auto &goodConnection : sendConnections)
    {
      Match currentMatch = match(goodConnection.address, p.address);
      if (currentMatch.negative <= bestMatch.negative)
      {
        sendConnection = goodConnection;
        bestMatch = currentMatch;
      }
    }

    Serial.print("Sending data via pin ");
    Serial.println(sendConnection.pin);

    return sendConnection.pin;
  }

  uint8_t recieve(Pocket p)
  {
    if (eq(you, p.address))
    {
      return 0;
    }
    else
    {
      return send(p);
    }
  }
};

//filepath: src\protocoll\physikal.hpp
#pragma once

#include <Arduino.h>
#include <vector>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <functional>

#include "logical.hpp"

#define NORMAL_SEND 1
#define RETURN_OK 2
#define RESEND_TIMEOUT 5000 // milliseconds
#define MAX_ATTEMPTS 3

using std::vector;

struct PendingPacket
{
  Pocket pocket;
  uint8_t sendPin;
  uint8_t attempts;
  unsigned long lastSendTime; // in milliseconds

  PendingPacket(const Pocket &p, uint8_t pin, uint8_t att, unsigned long time)
      : pocket(p), sendPin(pin), attempts(att), lastSendTime(time) {}
};

struct PhysikalNode
{
  Node logicalNode;
  TaskHandle_t taskHandle = nullptr;
  vector<PendingPacket> pendingPackets;

  static void loopTask(void *params)
  {
    static_cast<PhysikalNode *>(params)->loop();
  }

  void receivePocket(uint8_t pin);

  void sendNormalPocket(Pocket &p, uint8_t pin);

  std::function<void(const char *data)> onData = nullptr;

  // Handles a packet once received.
  void on(Pocket p)
  {
    uint8_t sendPin = logicalNode.recieve(p);
    if (sendPin == 0)
    {
      onData(p.data);
    }
    else
    {
      sendNormalPocket(p, sendPin);
    }
  }

  // Finds and acknowledges the pending packet based on its checksum.
  void acknowledge(uint16_t hash)
  {
    for (auto it = pendingPackets.begin(); it != pendingPackets.end(); ++it)
    {
      if (it->pocket.checksum == hash)
      {
        pendingPackets.erase(it);
        break;
      }
    }
  }

  // Checks for packets that need to be resent.
  void checkPendingAcks();

  // The main loopâ€”pulses the connections and checks for incoming data or ACKs.
  void loop()
  {
    // Pulse each connection to signal presence (adjust as needed)
    for (auto conn : logicalNode.connections)
    {
      // Uncomment to use pulsing signals if needed:
      // pinMode(conn.pin, OUTPUT);
      // digitalWrite(conn.pin, HIGH);
      // delayMicroseconds(1000);
      // digitalWrite(conn.pin, LOW);
      pinMode(conn.pin, INPUT);
    }

    while (true)
    {
      for (auto conn : logicalNode.connections)
      {
        if (digitalRead(conn.pin) == HIGH)
        {
          delayMicroseconds(1500);
          receivePocket(conn.pin);
        }
      }
      checkPendingAcks();
      // Yield to other tasks to avoid watchdog resets.
      vTaskDelay(pdMS_TO_TICKS(1));
    }
  }

  // Starts the FreeRTOS task for handling the physical layer communications.
  void start()
  {
    if (taskHandle == nullptr)
    {
      xTaskCreate(loopTask, "PhysLoop", 4096, this, 1, &taskHandle);
    }
  }

  // Stops the FreeRTOS task, if running.
  void stop()
  {
    if (taskHandle != nullptr)
    {
      vTaskDelete(taskHandle);
      taskHandle = nullptr;
    }
  }

  // Initiates the sending of a packet with the given address and data.
  void send(Address address, const char *data)
  {
    on(Pocket(address, data));
  }
};

#include "./raw-communication.hpp"
#include "./check-pending-acks.hpp"
#include "./receive-pocket.hpp"
#include "./send-normal-pocket.hpp"


//filepath: src\protocoll\raw-communication.hpp
#pragma once

#include <Arduino.h>

uint8_t readByte(uint8_t pin)
{
    uint8_t value = 0;
    for (int i = 0; i < 8; i++)
    {
        value |= (digitalRead(pin) << (7 - i));
        delayMicroseconds(1000);
    }
    return value;
}

uint16_t readUInt16(uint8_t pin)
{
    uint8_t low = readByte(pin);
    uint8_t high = readByte(pin);
    return (high << 8) | low;
}

void sendByte(uint8_t pin, uint8_t byte)
{
    for (int i = 7; i >= 0; i--)
    {
        digitalWrite(pin, (byte >> i) & 1);
        delayMicroseconds(1000);
    }
    digitalWrite(pin, LOW);
}

void sendUInt16(uint8_t pin, uint16_t val)
{
    sendByte(pin, val & 0xFF);
    sendByte(pin, val >> 8);
}

//filepath: src\protocoll\receive-pocket.hpp
#pragma once

#include "./physikal.hpp"

void PhysikalNode::receivePocket(uint8_t pin)
{
    uint8_t pocketType = readByte(pin);

    if (pocketType == NORMAL_SEND)
    {
        uint16_t addrSize = readUInt16(pin);
        Address address;
        for (int i = 0; i < addrSize; i++)
        {
            address.push_back(readUInt16(pin));
        }

        char data[11];
        for (int i = 0; i < 10; i++)
        {
            data[i] = readByte(pin);
        }
        data[10] = '\0';

        uint16_t checksum = readUInt16(pin);

        Pocket p(address, data);

        // Debug prints to verify checksum
        Serial.println("Received data: ");
        Serial.println(data);
        Serial.print("Computed checksum: ");
        Serial.println(p.checksum);
        Serial.print("Received checksum: ");
        Serial.println(checksum);

        if (p.checksum != checksum)
        {
            Serial.println("Checksum mismatch!");
            return;
        }

        pinMode(pin, OUTPUT);
        delayMicroseconds(1000);
        sendByte(pin, RETURN_OK);
        sendUInt16(pin, p.checksum);
        pinMode(pin, INPUT);

        on(p);
    }
    else if (pocketType == RETURN_OK)
    {
        uint16_t hash = readUInt16(pin);
        acknowledge(hash);
    }
}

//filepath: src\protocoll\send-normal-pocket.hpp
#pragma once

#include "./physikal.hpp"

void PhysikalNode::sendNormalPocket(Pocket &p, uint8_t pin)
{
    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);
    delayMicroseconds(1000);

    sendByte(pin, NORMAL_SEND);
    sendUInt16(pin, p.address.size());
    for (auto a : p.address)
        sendUInt16(pin, a);
    for (int i = 0; i < 10; i++)
        sendByte(pin, p.data[i]);
    sendUInt16(pin, p.checksum);

    pinMode(pin, INPUT); // Switch back to receive mode

    // Add packet to pendingPackets only if it is not already pending
    bool alreadyPending = false;
    for (auto &pending : pendingPackets)
    {
        if (pending.pocket.checksum == p.checksum)
        {
            alreadyPending = true;
            break;
        }
    }
    if (!alreadyPending)
    {
        pendingPackets.push_back(PendingPacket(p, pin, 1, millis()));
    }
}

//filepath: src\user.hpp
#define IS_SENDER 1

